<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Mila | Crypto Trade Companion üîçüìä ‚Äî Full</title>

<!-- Tailwind for design -->
<script src="https://cdn.tailwindcss.com"></script>

<!-- Chart.js + financial plugin -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@3.3.0/dist/chartjs-chart-financial.umd.min.js"></script>

<style>
:root{
  --bg:#061016; --card:#0d1620; --muted:#98a3b3; --accent:#00ff95; --danger:#ff6b6b; --glass: rgba(255,255,255,0.02);
}
body{background:var(--bg); color:#e7eef6; font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial; margin:0; padding:18px;}
.container {max-width:1200px; margin:0 auto;}
.header {display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:18px;}
.brand {display:flex; align-items:center; gap:12px;}
.logo {width:56px; height:56px; border-radius:12px; background:linear-gradient(135deg,#001f2d,#00333f); display:flex; align-items:center; justify-content:center; font-weight:800; color:var(--accent);}
.title {font-size:20px; font-weight:700;}
.subtitle {color:var(--muted); font-size:13px;}
.card {background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02)); border-radius:12px; padding:14px; box-shadow:0 8px 30px rgba(0,0,0,0.6);}
.grid {display:grid; gap:14px;}
@media(min-width:1024px){ .main-grid {grid-template-columns:360px 1fr; gap:18px;} .right-grid{grid-template-columns:1fr 420px; gap:14px;} }
.pill{display:inline-block;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);font-size:12px}
.mono{font-variant-numeric:tabular-nums;}
.flash { animation:flash 900ms linear infinite; }
@keyframes flash { 0%{box-shadow:0 0 0 rgba(255,0,0,0)} 50%{box-shadow:0 0 18px rgba(255,0,0,0.12)} 100%{box-shadow:0 0 0 rgba(255,0,0,0)} }
.small {font-size:12px; color:var(--muted);}
.kv {display:flex; justify-content:space-between; gap:6px; align-items:center;}
.chart-wrap {height:380px;}
.badge {display:inline-block;padding:6px 8px;border-radius:8px;background:rgba(0,0,0,0.35);font-size:12px}
</style>
</head>
<body>
  <div class="container">
    <header class="header">
      <div class="brand">
        <div class="logo">MILA</div>
        <div>
          <div class="title">Mila Trade Assistant ‚Äî Full Suite</div>
          <div class="subtitle">EMA gravity ‚Ä¢ ADR zones ‚Ä¢ Psych levels ‚Ä¢ Vector & PVSRA ‚Ä¢ Orderbook depth ‚Ä¢ Multi-API fallbacks</div>
        </div>
      </div>
      <div class="kv">
        <div class="pill mono" id="status">idle</div>
        <div class="small">Saved Rules: <span class="mono">Never strip code ‚Ä¢ Prefer deep/complex</span></div>
      </div>
    </header>

    <main class="grid main-grid">
      <!-- LEFT: Controls -->
      <aside class="card">
        <div>
          <label class="small">1) Search coin (name or symbol)</label>
          <input id="search" class="w-full mt-2 p-3 rounded-lg bg-[#071018] border border-[#12303b] mono" placeholder="Type: bitcoin, dolo, internet computer..." />
          <div id="suggestions" class="mt-2 max-h-48 overflow-auto"></div>
        </div>

        <div class="mt-4">
          <label class="small">Quote / Base</label>
          <select id="quote" class="w-full mt-2 p-2 rounded-lg bg-[#071018] border border-[#12303b]">
            <option value="USDT">USDT</option>
            <option value="USDC">USDC</option>
            <option value="BUSD">BUSD</option>
            <option value="BTC">BTC</option>
          </select>
        </div>

        <div class="mt-3">
          <label class="small">Timeframe</label>
          <select id="tf" class="w-full mt-2 p-2 rounded-lg bg-[#071018] border border-[#12303b]">
            <option value="15m">15m</option>
            <option value="1h" selected>1h</option>
            <option value="4h">4h</option>
            <option value="1d">1d</option>
          </select>
        </div>

        <button id="fetchBtn" class="w-full mt-4 p-3 rounded-lg bg-[var(--accent)] text-black font-semibold">Fetch & Analyze</button>

        <div class="mt-4 grid gap-2">
          <button id="suggestBtn" class="p-2 rounded-lg bg-[#2b6be8]">Auto-fill Mila SL/TP (suggest)</button>
          <button id="evalBtn" class="p-2 rounded-lg bg-[#00c2a8]">Evaluate Plan (size, RR, sanity)</button>
        </div>

        <div class="mt-4 small">
          <div>Data order: Binance ‚Üí CoinGecko ‚Üí CoinMarketCap (CMC). If Binance available, full TA & orderbook shown.</div>
          <div class="mt-2">Warning: CMC key visible client-side in this single-file demo. Use serverless proxy for production. (Proxy snippet at bottom)</div>
        </div>
      </aside>

      <!-- RIGHT: Chart + Readouts -->
      <section class="grid right-grid">
        <!-- Chart Card -->
        <div class="card">
          <div class="flex items-start justify-between">
            <div>
              <div id="pair" class="text-xl font-semibold mono">‚Äî</div>
              <div id="meta" class="small text-[var(--muted)] mt-1">no symbol selected</div>
            </div>
            <div class="text-right">
              <div id="price" class="text-lg mono">‚Äî</div>
              <div id="session" class="small text-[var(--muted)]">session</div>
            </div>
          </div>

          <div class="chart-wrap mt-3">
            <canvas id="chart"></canvas>
          </div>

          <div class="mt-3 grid grid-cols-3 gap-3">
            <div class="small"><b>ADR(14):</b> <span id="adrVal">‚Äî</span></div>
            <div class="small"><b>EMA50:</b> <span id="ema50">‚Äî</span></div>
            <div class="small"><b>Vectors:</b> <span id="vecCount">‚Äî</span></div>
          </div>
        </div>

        <!-- Right column: Stats & plan -->
        <div>
          <div class="card mb-3">
            <div class="flex justify-between items-start">
              <div>
                <div class="small text-[var(--muted)]">Market Fundamentals</div>
                <div id="mcaps" class="text-sm mono mt-1">‚Äî</div>
              </div>
              <div>
                <img id="logo" src="" class="w-12 h-12 rounded-md" style="display:none"/>
              </div>
            </div>

            <div class="mt-3">
              <div class="small">Orderbook (top 5)</div>
              <div id="orderbook" class="mt-2 small text-[var(--muted)]">‚Äî</div>
            </div>
          </div>

          <div class="card mb-3">
            <div class="small text-[var(--muted)]">Mila‚Äôs Sanity Zone</div>
            <div id="sanity" class="mt-2 mono small">‚Äî</div>
            <div id="psych" class="mt-2 small text-[var(--muted)]">‚Äî</div>
          </div>

          <div class="card">
            <div class="small text-[var(--muted)]">Mila‚Äôs Verdict</div>
            <div id="verdict" class="mt-2"></div>
          </div>
        </div>

        <!-- Below chart: Plan area spanning full width -->
        <div class="card md:col-span-2">
          <h3 class="text-lg font-semibold">Plan vs Reality ‚Äî Input your trade</h3>
          <div class="grid grid-cols-1 md:grid-cols-4 gap-3 mt-3">
            <input id="entry" placeholder="Entry" class="p-2 rounded bg-[#071018] mono"/>
            <input id="stop" placeholder="Stop Loss" class="p-2 rounded bg-[#071018] mono"/>
            <input id="tp1" placeholder="TP1" class="p-2 rounded bg-[#071018] mono"/>
            <input id="tp2" placeholder="TP2" class="p-2 rounded bg-[#071018] mono"/>
            <input id="tpF" placeholder="Final TP" class="p-2 rounded bg-[#071018] mono"/>
            <input id="balance" placeholder="Balance USDT" value="2000" class="p-2 rounded bg-[#071018] mono"/>
            <input id="riskPct" placeholder="Risk %" value="1" class="p-2 rounded bg-[#071018] mono"/>
            <select id="side" class="p-2 rounded bg-[#071018] mono"><option value="long">Long</option><option value="short">Short</option></select>
          </div>

          <div id="planOutput" class="mt-4 small mono">No plan evaluated.</div>
        </div>
      </section>
    </main>
  </div>

<script>
/* ================== FULL MILA ENGINE ==================
   Single-file full implementation. No external server required to test.
   WARNING: CMC key is included in this file (visible). For production, create a serverless proxy and replace CMC calls with the proxy endpoint.
   CMC key (user-provided) - visible here:
*/
const CMC_KEY = "7c349fb2-99f1-4e60-8a50-0b0323354923";
const BINANCE = "https://spectacular-pixie-ead723.netlify.app/.netlify/functions/binance-proxy";
const COINGECKO = "https://api.coingecko.com/api/v3";
const CMC_API = "https://pro-api.coinmarketcap.com/v1";
const proxyServer = true;


/* Utility */
const $ = id => document.getElementById(id);
const fmt = (n,d=4)=> Number.isFinite(n)? Number(n).toFixed(d): "‚Äî";
const setStatus = s => $("status").textContent = s;

/* State */
let selected = null;
let lastState = null;
let chartInstance = null;

/* ----------------- Autocomplete via CoinGecko ----------------- */
let searchTimer = null;
$("search").addEventListener("input", (e) => {
  clearTimeout(searchTimer);
  const v = e.target.value.trim();
  if(!v) { $("suggestions").innerHTML=""; return; }
  searchTimer = setTimeout(()=> searchCoins(v), 250);
});

async function searchCoins(q){
  try{
    setStatus("searching");
    const res = await fetch(`${COINGECKO}/search?query=${encodeURIComponent(q)}`);
    const j = await res.json();
    const coins = j.coins.slice(0,10);
    const html = coins.map(c=> `
      <div class="flex items-center gap-3 p-2 hover:bg-[#06161b] cursor-pointer" onclick='selectCoin(${JSON.stringify(JSON.stringify(c))})'>
        <img src="${c.thumb}" class="w-6 h-6 rounded-full"/>
        <div>
          <div class="mono">${c.name} <span class="small text-[var(--muted)]">(${c.symbol.toUpperCase()})</span></div>
          <div class="small text-[var(--muted)]">${c.market_cap_rank? 'rank '+c.market_cap_rank : ''}</div>
        </div>
      </div>
    `).join("");
    $("suggestions").innerHTML = html || "<div class='small p-2 text-[var(--muted)]'>no results</div>";
    setStatus("ready");
  }catch(e){
    $("suggestions").innerHTML = "<div class='small p-2 text-[var(--muted)]'>search error</div>";
    setStatus("error");
  }
}

/* select coin from list */
function selectCoin(str){
  const obj = JSON.parse(str);
  selected = { id: obj.id, symbol: obj.symbol.toUpperCase(), name: obj.name, thumb: obj.large || obj.thumb };
  $("search").value = `${selected.name} (${selected.symbol})`;
  $("suggestions").innerHTML = "";
  setStatus("coin selected");
}

/* ----------------- Pair resolution (Binance) ----------------- */
async function resolvePair(symbol, quote){
  // Ensure uppercase
  const sym = symbol.replace(/\s+/g,'').toUpperCase();
  const tries = [sym+quote, sym+'USDT', sym+'BUSD', sym+'USDC', sym+'BTC', sym+'ETH'];
  for(const p of tries){
    try{
      const r = await fetch(`${BINANCE}/api/v3/ticker/price?symbol=${p}`);
      if(r.ok) { return p; }
    }catch(e){}
  }
  return null;
}

/* ----------------- Fetch klines (multi-source) ----------------- */
async function fetchKlines(pair, interval='1h', limit=500){
  // Binance first
  try{
    const r = await fetch(`${BINANCE}/api/v3/klines?symbol=${pair}&interval=${interval}&limit=${limit}`);
    if(r.ok){
      const raw = await r.json();
      // map to objects
      return raw.map(d=>({ t:+d[0], o:+d[1], h:+d[2], l:+d[3], c:+d[4], v:+d[5] }));
    }
  }catch(e){ console.warn('binance klines fail', e); }

  // CoinGecko fallback (only daily support) for 1d
  if(interval==='1d' && selected){
    try{
      const j = await fetch(`${COINGECKO}/coins/${selected.id}/ohlc?vs_currency=usd&days=14`).then(r=>r.json());
      // ascending; convert to array of objects
      return j.reverse().map(d=>({ t:d[0], o:d[1], h:d[2], l:d[3], c:d[4], v:0 }));
    }catch(e){ console.warn('cg ohlc fail', e); }
  }

  // CMC fallback (requires key) - historical OHLC
  try{
    const sym = pair.replace(/USDT|BUSD|USDC|BTC|ETH/gi,'') || selected?.symbol;
    const url = `${CMC_API}/cryptocurrency/ohlcv/historical?symbol=${encodeURIComponent(sym)}&convert=USD&count=30`;
    const r = await fetch(url, { headers: {'X-CMC_PRO_API_KEY': CMC_KEY }});
    if(r.ok){
      const j = await r.json();
      const quotes = j.data.quotes;
      return quotes.map(q=>({ t:new Date(q.time_open).getTime(), o:q.quote.USD.open, h:q.quote.USD.high, l:q.quote.USD.low, c:q.quote.USD.close, v:q.quote.USD.volume })).reverse();
    }
  }catch(e){ console.warn('cmc ohlc fail', e); }

  throw new Error('No OHLC source available');
}

/* ----------------- Orderbook ----------------- */
async function fetchOrderbook(pair){
  try{
    const r = await fetch(`${BINANCE}/api/v3/depth?symbol=${pair}&limit=50`);
    if(r.ok){
      const j = await r.json();
      const bids = j.bids.map(b=>({p:+b[0], q:+b[1]}));
      const asks = j.asks.map(a=>({p:+a[0], q:+a[1]}));
      const bidQ = bids.reduce((s,b)=>s+b.q,0);
      const askQ = asks.reduce((s,a)=>s+a.q,0);
      const skew = (bidQ - askQ) / (bidQ + askQ);
      return { bids, asks, bidQ, askQ, skew };
    }
  }catch(e){ console.warn('orderbook fail', e); }
  return null;
}

/* ----------------- Technicals: EMA, ADR, Psych, Vectors ----------------- */
function emaArray(arr, period){
  if(arr.length < period) return Array(arr.length).fill(null);
  const k = 2/(period+1);
  let out = new Array(arr.length).fill(null);
  let seed = arr.slice(0,period).reduce((a,b)=>a+b,0)/period;
  out[period-1] = seed;
  let prev = seed;
  for(let i=period;i<arr.length;i++){
    prev = arr[i]*k + prev*(1-k);
    out[i] = prev;
  }
  return out;
}

function computeADR(dailyCandles){
  const ranges = dailyCandles.map(c => Math.abs(c.h - c.l));
  const adr = ranges.reduce((a,b)=>a+b,0)/ranges.length;
  return adr;
}

function smartPsych(price){
  // choose steps based on magnitude
  if(price>=1000) { const s=100; const base=Math.round(price/100)*100; return [base-200,base-100,base,base+100,base+200]; }
  if(price>=100)  { const s=10; const base=Math.round(price/10)*10; return [base-50,base-20,base,base+20,base+50]; }
  if(price>=10)   { const s=1; const base=Math.round(price); return [base-5,base-2,base,base+2,base+5]; }
  if(price>=1)    { const s=0.1; const base=Math.round(price*10)/10; return [Number((base-0.5).toFixed(4)),Number((base-0.2).toFixed(4)),base,Number((base+0.2).toFixed(4)),Number((base+0.5).toFixed(4))]; }
  return [Number((price-0.05).toFixed(6)), Number((price-0.02).toFixed(6)), Number(price.toFixed(6)), Number((price+0.02).toFixed(6)), Number((price+0.05).toFixed(6))];
}

function detectVectors(candles){
  // Simple PVSRA vector detection: body >= 60% of range AND vol > 1.6*sma20
  const vols = candles.map(c=>c.v || 0);
  const sma20 = vols.map((_,i) => i<19 ? null : vols.slice(i-19,i+1).reduce((a,b)=>a+b,0)/20);
  let vectors = [];
  for(let i=0;i<candles.length;i++){
    const c = candles[i];
    const body = Math.abs(c.c - c.o);
    const range = (c.h - c.l) || 1;
    const bodyPct = body/range;
    const spike = sma20[i] ? c.v > 1.6 * sma20[i] : false;
    if(bodyPct >= 0.6 && spike) vectors.push({ idx:i, dir: c.c > c.o ? 'green':'red', t:c.t, price:c.c });
  }
  return vectors;
}

/* ----------------- Session rhythm ----------------- */
function sessionFromTS(ts){
  const d = new Date(ts); const h = d.getUTCHours();
  if(h>=0 && h<7) return 'Asian';
  if(h>=7 && h<16) return 'London';
  return 'New York';
}

/* ----------------- Mila interpretation engine ----------------- */
function milaRead(state, side='long'){
  // inputs: state contains price, adr, adrLo/Hi, emas, vectors, ob, psych
  const { price, adr, psych, emas, vectors, ob } = state;
  // bias
  const e50 = emas.e50?.slice(-1)[0] || null, e200 = emas.e200?.slice(-1)[0] || null, e800 = emas.e800?.slice(-1)[0] || null;
  let bias = 'neutral';
  if(e50 && price > e50) bias = 'bullish';
  if(e50 && price < e50) bias = 'bearish';

  // vector context
  const lastVec = vectors.slice(-6);
  const greenCount = lastVec.filter(v=>v.dir==='green').length;
  const redCount = lastVec.filter(v=>v.dir==='red').length;

  // suggested risk
  const volRatio = state.adr / state.price;
  let suggestedRisk = 1.0;
  if(volRatio > 0.06) suggestedRisk = 0.5;
  if(volRatio < 0.02) suggestedRisk = 1.5;
  if(greenCount > redCount && bias==='bullish') suggestedRisk = Math.min(suggestedRisk, 0.5);

  // suggested SL/TPs
  let sSL, sTP1, sTP2, sTPF;
  if(side === 'long'){
    sSL = Math.max(state.adrLo*0.995, price - state.adr*0.45);
    sTP1 = price + state.adr*0.5;
    sTP2 = Math.min(price + state.adr*0.9, state.adrHi*0.998);
    sTPF = Math.min(price + state.adr*1.3, state.adrHi*1.02);
  } else {
    sSL = Math.min(state.adrHi*1.005, price + state.adr*0.45);
    sTP1 = price - state.adr*0.5;
    sTP2 = Math.max(price - state.adr*0.9, state.adrLo*1.002);
    sTPF = Math.max(price - state.adr*1.3, state.adrLo*0.98);
  }

  // nearest psych
  const nearestPsych = psych.reduce((acc,p)=> Math.abs(p - price) < Math.abs(acc - price) ? p : acc, psych[0]);

  // narrative
  let notes = [];
  notes.push(`Bias: ${bias}. Price ${price > e50 ? 'above' : 'below'} 50EMA${e50?` (${fmt(e50)})`:''}.`);
  if(greenCount > redCount) notes.push(`Recent green vector dominance (${greenCount} vs ${redCount}) ‚Äî MM closing longs possible.`);
  if(redCount > greenCount) notes.push(`Recent red vector dominance (${redCount} vs ${greenCount}) ‚Äî shorts being closed may attract buys.`);
  if(ob) notes.push(`Orderbook skew: ${(ob.skew>0? 'bids dominant':'asks dominant')} (bidŒ£=${fmt(ob.bidQ,2)}, askŒ£=${fmt(ob.askQ,2)}).`);
  notes.push(`Nearest psych: ${fmt(nearestPsych)}. ADR: ${fmt(adr)}.`);

  return {
    notes, suggestedRisk, recommended: { sSL, sTP1, sTP2, sTPF }, bias, nearestPsych
  };
}

/* ----------------- Chart rendering ----------------- */
function renderChart(candles, emas){
  const ctx = $("chart").getContext('2d');
  const data = candles.map(c=>({x:new Date(c.t), o:c.o, h:c.h, l:c.l, c:c.c}));
  const ema50 = emas.e50.map((v,i)=> v? ({x:new Date(candles[i].t), y:v}) : null).filter(Boolean);
  const ema200 = emas.e200.map((v,i)=> v? ({x:new Date(candles[i].t), y:v}) : null).filter(Boolean);

  if(chartInstance) chartInstance.destroy();
  chartInstance = new Chart(ctx, {
    type: 'candlestick',
    data: {
      datasets: [
        { label: 'Price', data: data, borderColor:'#9aa4b2' },
        { label: 'EMA50', type:'line', data: ema50, borderColor:'#00ff95', borderWidth:1.2, pointRadius:0 },
        { label: 'EMA200', type:'line', data: ema200, borderColor:'#7aa2f7', borderWidth:1.2, pointRadius:0 }
      ]
    },
    options: {
      parsing:false, maintainAspectRatio:false,
      plugins:{ legend:{ labels:{ color:'#e6edf3' } } },
      scales:{ x:{ ticks:{ color:'#9aa4b2' } }, y:{ ticks:{ color:'#9aa4b2' }}}
    }
  });
}

/* ----------------- Sizing & Plan evaluation ----------------- */
function evaluateUserPlan(form, state){
  // form: {entry, stop, tp1, tp2, tpF, balance, riskPct, side}
  const entry = +form.entry, stop = +form.stop, tp1=+form.tp1, tp2=+form.tp2, tpF=+form.tpF;
  const balance = +form.balance || 0, riskPct = +form.riskPct || 1, side = form.side || 'long';
  const riskAmt = balance * (riskPct/100);
  const stopDist = Math.abs(entry - stop);
  const qty = stopDist>0? (riskAmt / stopDist) : 0;
  const rr = (t)=> Math.abs((t - entry) / (entry - stop));

  const mila = milaRead(state, side);

  const issues = [];
  if(side==='long' && entry > state.adrHi) issues.push('Entry above ADR high ‚Äî trap risk.');
  if(side==='short' && entry < state.adrLo) issues.push('Entry below ADR low ‚Äî trap risk.');
  if(Math.abs(stop - mila.recommended.sSL) / Math.abs(mila.recommended.sSL) > 0.35) issues.push('Your SL is far from Mila suggested SL (structural mismatch).');

  return {
    sizing:{ riskAmt, qty },
    rrs:{ r1:rr(tp1), r2:rr(tp2), rF:rr(tpF) },
    issues, mila
  };
}

/* ----------------- UI glue: fetch & analyze ----------------- */
$("fetchBtn").addEventListener("click", async ()=>{
  try{
    if(!selected){ alert('Pick a coin from suggestions first'); return; }
    setStatus('resolving pair');
    const quote = $("quote").value || 'USDT';
    const tf = $("tf").value || '1h';
    // resolve pair
    const pair = await resolvePair(selected.symbol, quote) || await resolvePair(selected.symbol, 'USDT');
    if(!pair){
      // produce fallback price via CoinGecko
      setStatus('fallback: coingecko');
      const priceObj = await fetch(`${COINGECKO}/simple/price?ids=${selected.id}&vs_currencies=usd&include_market_cap=true&include_24hr_vol=true&include_24hr_change=true`).then(r=>r.json());
      const p = priceObj[selected.id].usd;
      const mcap = priceObj[selected.id].usd_market_cap;
      // crude sanity zone
      const adr = p * 0.05;
      const state = { pair: selected.symbol + '/USD (CG)', source:'coingecko', price:p, adr, adrHi:p+adr, adrLo:p-adr, psych: smartPsych(p), emas:{}, vectors:[], ob:null, candles:[] };
      lastState = state;
      renderFallback(state);
      setStatus('ready (fallback)');
      return;
    }

    setStatus('fetching klines');
    // fetch klines
    const klines = await fetchKlines(pair, tf, 500);
    // daily for ADR
    const daily = await fetchKlines(pair.replace(/(USDT|BUSD|USDC|BTC|ETH)$/i,'' ) + quote, '1d', 30).catch(()=>null);
    const dailyCandles = await fetchKlines(pair, '1d', 30).catch(()=>null);
    const adr = dailyCandles? computeADR(dailyCandles) : (Math.max(...klines.map(c=>c.h)) - Math.min(...klines.map(c=>c.l)));
    const price = klines.at(-1).c;
    const psych = smartPsych(price);
    // EMAs from closes
    const closes = klines.map(k=>k.c);
    const emas = { e5: emaArray(closes,5), e13: emaArray(closes,13), e50: emaArray(closes,50), e200: emaArray(closes,200), e800: closes.length>=800? emaArray(closes,800) : null };
    const vectors = detectVectors(klines);
    const ob = await fetchOrderbook(pair);
    const state = { pair, source:'binance', price, adr, adrHi: price + adr, adrLo: price - adr, psych, emas, vectors, ob, candles:klines };
    lastState = state;

    // render UI blocks
    $("pair").textContent = pair;
    $("meta").textContent = `${selected.name} ‚Ä¢ ${selected.symbol} ‚Ä¢ ${tf} ‚Ä¢ source: Binance`;
    $("price").textContent = fmt(price,6);
    $("session").textContent = sessionFromTS(klines.at(-1).t);
    $("logo").src = selected.thumb; $("logo").style.display = 'block';

    // ADR / EMA / vectors / orderbook / psych
    $("adrVal").textContent = fmt(state.adr,6);
    $("ema50").textContent = state.emas.e50.at(-1)? fmt(state.emas.e50.at(-1),6) : '‚Äî';
    $("vecCount").textContent = state.vectors.length;

    // mcap & ccap via CMC (optional)
    try{
      const symbolShort = selected.symbol.replace(/USDT|USD/gi,'');
      const cmcRes = await fetch(`${CMC_API}/cryptocurrency/info?symbol=${symbolShort}`, { headers: {'X-CMC_PRO_API_KEY': CMC_KEY} }).then(r=>r.json()).catch(()=>null);
      const cmcQuote = await fetch(`${CMC_API}/cryptocurrency/quotes/latest?symbol=${symbolShort}&convert=USD`, { headers:{ 'X-CMC_PRO_API_KEY': CMC_KEY } }).then(r=>r.json()).catch(()=>null);
      if(cmcQuote?.data && cmcQuote.data[symbolShort]){
        const q = cmcQuote.data[symbolShort].quote.USD;
        $("mcaps").innerHTML = `Market cap: <b>${q.market_cap? '$'+Math.round(q.market_cap).toLocaleString() : '‚Äî'}</b> ‚Ä¢ 24h vol: <b>${q.volume_24h? '$'+Math.round(q.volume_24h).toLocaleString(): '‚Äî'}</b> ‚Ä¢ Change24h: <b>${q.percent_change_24h? q.percent_change_24h.toFixed(2)+'%':'‚Äî'}</b>`;
      } else {
        $("mcaps").textContent = 'Fundamentals unavailable';
      }
    }catch(e){ $("mcaps").textContent = 'Fundamentals unavailable'; }

    // orderbook
    if(ob){
      const topB = ob.bids.slice(0,5).map(b=>`${fmt(b.p,6)} (${fmt(b.q,2)})`).join('<br>');
      const topA = ob.asks.slice(0,5).map(a=>`${fmt(a.p,6)} (${fmt(a.q,2)})`).join('<br>');
      $("orderbook").innerHTML = `<div class="grid grid-cols-2 gap-4"><div><b>Bids</b><div class="mt-1 small">${topB}</div></div><div><b>Asks</b><div class="mt-1 small">${topA}</div></div></div>`;
    } else { $("orderbook").textContent = 'Orderbook not available'; }

    // Sanity zone & psych
    const mila = milaRead(state, 'long');
    $("sanity").innerHTML = `Entry ~ <b class="mono">${fmt(state.price,6)}</b><br/>SL ~ <b class="mono">${fmt(mila.recommended.sSL,6)}</b><br/>TP1 <b class="mono">${fmt(mila.recommended.sTP1,6)}</b> ‚Ä¢ TP2 <b class="mono">${fmt(mila.recommended.sTP2,6)}</b> ‚Ä¢ Final <b class="mono">${fmt(mila.recommended.sTPF,6)}</b>`;
    $("psych").innerHTML = `Psych levels: ${state.psych.map(p=>`<span class="pill mono">${fmt(p,6)}</span>`).join(' ')}`;

    // Verdict
    $("verdict").innerHTML = `<div>${mila.notes.map(n=>`<div class="small">${n}</div>`).join('')}</div><div class="mt-2 small text-[var(--muted)]">Suggested risk: <b>${fmt(mila.suggestedRisk,2)}%</b> ‚Ä¢ Nearest psych: <b>${fmt(mila.nearestPsych,6)}</b></div>`;

    // Chart
    renderChart(state.candles.slice(-200), state.emas);

    setStatus('ready (binance)');
  }catch(err){
    console.error(err);
    setStatus('error');
    alert('Fetch failed. See console for details.');
  }
});

/* ----------------- Suggest & Evaluate handlers ----------------- */
$("suggestBtn").addEventListener("click", ()=>{
  if(!lastState){ alert('Fetch a coin first'); return; }
  const rec = milaRead(lastState, $("side").value || 'long');
  $("stop").value = fmt(rec.recommended.sSL,6);
  $("tp1").value = fmt(rec.recommended.sTP1,6);
  $("tp2").value = fmt(rec.recommended.sTP2,6);
  $("tpF").value = fmt(rec.recommended.sTPF,6);
  setStatus('suggested filled');
});

$("evalBtn").addEventListener("click", ()=>{
  if(!lastState){ alert('Fetch a coin first'); return; }
  const form = {
    entry: +$("entry").value, stop:+$("stop").value, tp1:+$("tp1").value, tp2:+$("tp2").value, tpF:+$("tpF").value,
    balance:+$("balance").value||0, riskPct:+$("riskPct").value||1, side:$("side").value||'long'
  };
  if(!isFinite(form.entry) || !isFinite(form.stop)){ alert('Entry & Stop required'); return; }
  const res = evaluateUserPlan(form, lastState);
  const sizing = res.sizing;
  const rrs = res.rrs;
  const issues = res.issues;
  const out = `
    <div>Risk $: <b class="mono">${fmt(sizing.riskAmt,2)}</b> ‚Ä¢ Qty: <b class="mono">${fmt(sizing.qty,6)}</b></div>
    <div class="mt-2 small">R:R ‚Üí TP1: <b>${fmt(rrs.r1,2)}</b> ‚Ä¢ TP2: <b>${fmt(rrs.r2,2)}</b> ‚Ä¢ Final: <b>${fmt(rrs.rF,2)}</b></div>
    <div class="mt-2">${issues.length? `<div class="small text-[var(--danger)]">${issues.map(i=>`‚Ä¢ ${i}`).join('<br>')}</div>` : '<div class="small text-[var(--muted)]">Plan is structurally aligned.</div>'}</div>
    <div class="mt-2 small text-[var(--muted)]">Mila suggested risk: <b>${fmt(res.mila.suggestedRisk,2)}%</b></div>
  `;
  $("planOutput").innerHTML = out;
  if(issues.length) $("planOutput").classList.add('flash'); else $("planOutput").classList.remove('flash');
});

/* ----------------- Inline PWA manifest & SW (single-file friendly) ----------------- */
(function registerPWA(){
  try{
    const manifest = {
      name: "Mila Trade Assistant",
      short_name: "MilaTA",
      start_url: ".",
      display: "standalone",
      background_color: "#061016",
      theme_color: "#00ff95",
      icons: [ { src: "data:image/svg+xml," + encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='512' height='512'><rect width='100%' height='100%' rx='80' fill='#0b1820'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-size='120' fill='#00ff95' font-family='Inter'>M</text></svg>`), sizes:"512x512", type:"image/svg+xml" } ]
    };
    const mm = new Blob([JSON.stringify(manifest)], {type:'application/json'});
    const url = URL.createObjectURL(mm);
    const link = document.createElement('link'); link.rel='manifest'; link.href = url; document.head.appendChild(link);

    const swCode = `
      const CACHE='mila-v1';
      self.addEventListener('install', e=>{ e.waitUntil(caches.open(CACHE).then(c=>c.addAll(['/','/index.html']))) ; self.skipWaiting(); });
      self.addEventListener('activate', e=>self.clients.claim());
      self.addEventListener('fetch', e=>{ e.respondWith(caches.match(e.request).then(r=> r|| fetch(e.request))); });
    `;
    const swBlob = new Blob([swCode], {type:'text/javascript'});
    const swUrl = URL.createObjectURL(swBlob);
    if('serviceWorker' in navigator){ navigator.serviceWorker.register(swUrl).then(()=>console.log('SW registered')).catch(()=>{/*silent*/}); }
  }catch(e){ console.warn('PWA inline failed', e); }
})();

/* ================== END ================== */

/* ----------------- Serverless proxy example (Netlify/Azure/Vercel) -----------------
  Save this as a serverless function to hide the CMC key. Then replace client CMC calls to /api/cmc?symbol=...
  Node (Netlify/Vercel) example (JavaScript):

  // netlify/functions/cmc.js
  const fetch = require('node-fetch');
  exports.handler = async (event) => {
    const { symbol } = event.queryStringParameters || {};
    const url = `https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest?symbol=${encodeURIComponent(symbol)}`;
    const res = await fetch(url, { headers: { 'X-CMC_PRO_API_KEY': process.env.CMC_KEY } });
    const json = await res.json();
    return { statusCode: 200, body: JSON.stringify(json) };
  };

  Deploy to Netlify/Vercel and set environment variable CMC_KEY to your secret. Then in client code:
    fetch('/.netlify/functions/cmc?symbol=DOLO') // instead of direct CMC call
-------------------------------------------------------------------------- */

</script>
</body>
</html>

