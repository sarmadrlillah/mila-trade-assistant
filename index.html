<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Mila Trade Assistant — Full</title>

<!-- Tailwind quick UI -->
<script src="https://cdn.tailwindcss.com"></script>

<!-- Chart.js + financial plugin -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@3.3.0/dist/chartjs-chart-financial.umd.min.js"></script>

<style>
  :root{
    --bg:#0b0f14; --card:#0f1720; --muted:#9aa4b2; --accent:#00ff95; --danger:#ff6b6b; --gold:#ffd166;
  }
  body{background:var(--bg); color:#e6edf3; font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin:0; padding:18px;}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02)); border-radius:14px; padding:14px; box-shadow:0 10px 30px rgba(0,0,0,0.5);}
  .mono{font-variant-numeric: tabular-nums;}
  .flash { animation:flash 1s linear infinite; }
  @keyframes flash{0%{box-shadow:none}50%{box-shadow:0 0 14px rgba(255,107,107,0.16)}100%{box-shadow:none}}
  a.small{color:var(--muted); font-size:12px}
  .pill{display:inline-block;padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);font-size:12px}
  /* responsive */
  @media(min-width:1024px){ .layout{display:grid;grid-template-columns:360px 1fr; gap:18px} }
</style>
</head>
<body>

<header class="max-w-6xl mx-auto mb-6">
  <div class="flex items-center justify-between">
    <div>
      <h1 class="text-2xl font-semibold">Mila Trade Assistant <span class="text-[var(--accent)]">Pro</span></h1>
      <div class="text-[var(--muted)] text-sm mt-1">Full Mila system — ADR, psych levels, EMAs, vectors, PVSRA, orderbook, multi-API fallbacks.</div>
    </div>
    <div class="text-right">
      <div class="pill mono" id="statusPill">idle</div>
    </div>
  </div>
</header>

<main class="max-w-6xl mx-auto layout">
  <!-- LEFT: Controls -->
  <section class="card">
    <h2 class="text-lg font-semibold mb-3">1) Find coin</h2>

    <label class="text-xs text-[var(--muted)]">Type name or symbol (CoinGecko search)</label>
    <input id="search" class="w-full p-3 rounded-lg mt-2 bg-[#071018] border border-[#17202a] mono" placeholder="Type: bitcoin, dolo, internet computer..." autocomplete="off" />

    <div id="suggestions" class="mt-2 max-h-44 overflow-auto"></div>

    <div class="mt-4">
      <label class="text-xs text-[var(--muted)]">Base quote (default)</label>
      <select id="quote" class="w-full p-2 mt-1 rounded-lg bg-[#071018] border border-[#17202a]">
        <option value="USDT">USDT</option>
        <option value="USD">USD</option>
        <option value="USDC">USDC</option>
        <option value="BTC">BTC</option>
      </select>
    </div>

    <div class="mt-4">
      <label class="text-xs text-[var(--muted)]">Timeframe</label>
      <select id="tf" class="w-full p-2 mt-1 rounded-lg bg-[#071018] border border-[#17202a]">
        <option value="15m">15m</option>
        <option value="1h" selected>1h</option>
        <option value="4h">4h</option>
        <option value="1d">1d</option>
      </select>
    </div>

    <button id="fetchBtn" class="w-full mt-4 p-3 rounded-lg bg-[var(--accent)] text-black font-semibold">Fetch & Analyze</button>

    <div class="mt-6">
      <h3 class="text-sm text-[var(--muted)] mb-2">Quick actions</h3>
      <div class="flex gap-2">
        <button id="savePlan" class="flex-1 p-2 rounded-lg bg-[#17232b]">Save plan</button>
        <button id="resetBtn" class="flex-1 p-2 rounded-lg bg-[#17232b]">Reset</button>
      </div>
    </div>

    <div class="mt-6 text-[var(--muted)] text-xs">
      <div>Data sources: Binance (first), CoinGecko (fallback), CoinMarketCap (fallback)</div>
      <div class="mt-2">⚠️ CMC key visible in page source. Use serverless proxy for production.</div>
    </div>
  </section>

  <!-- RIGHT: Chart & Deep Read -->
  <section>
    <div class="card mb-4">
      <div class="flex items-start justify-between">
        <div>
          <div id="pairTitle" class="text-xl font-semibold mono">—</div>
          <div id="pairSub" class="text-[var(--muted)] text-sm mt-1">Select coin to fetch</div>
        </div>
        <div class="text-right">
          <div id="priceLive" class="text-lg mono">—</div>
          <div id="sessionTag" class="text-xs text-[var(--muted)] mt-1">session</div>
        </div>
      </div>

      <div class="mt-4">
        <canvas id="chart" height="260"></canvas>
      </div>
    </div>

    <div class="grid md:grid-cols-3 gap-4 mb-4">
      <div class="card">
        <h4 class="text-sm text-[var(--muted)]">ADR & Psych</h4>
        <div id="adrBlock" class="mt-2 mono text-sm">—</div>
      </div>
      <div class="card">
        <h4 class="text-sm text-[var(--muted)]">EMA Gravity</h4>
        <div id="emaBlock" class="mt-2 mono text-sm">—</div>
      </div>
      <div class="card">
        <h4 class="text-sm text-[var(--muted)]">Orderbook</h4>
        <div id="obBlock" class="mt-2 mono text-sm">—</div>
      </div>
    </div>

    <div class="card mb-4">
      <h3 class="text-lg font-semibold">Mila’s Depth Read</h3>
      <div id="milaVerdict" class="mt-3 text-sm text-[var(--muted)]">—</div>
    </div>

    <div class="card">
      <h3 class="text-lg font-semibold">Plan vs Reality (enter below then click "Evaluate plan")</h3>
      <div class="grid grid-cols-2 gap-3 mt-3">
        <div>
          <label class="text-xs text-[var(--muted)]">Entry</label>
          <input id="entry" class="w-full p-2 mt-1 rounded bg-[#071018] mono"/>
        </div>
        <div>
          <label class="text-xs text-[var(--muted)]">Stop Loss</label>
          <input id="stop" class="w-full p-2 mt-1 rounded bg-[#071018] mono"/>
        </div>
        <div>
          <label class="text-xs text-[var(--muted)]">TP1</label>
          <input id="tp1" class="w-full p-2 mt-1 rounded bg-[#071018] mono"/>
        </div>
        <div>
          <label class="text-xs text-[var(--muted)]">TP2</label>
          <input id="tp2" class="w-full p-2 mt-1 rounded bg-[#071018] mono"/>
        </div>
        <div>
          <label class="text-xs text-[var(--muted)]">Final TP</label>
          <input id="tpF" class="w-full p-2 mt-1 rounded bg-[#071018] mono"/>
        </div>
        <div>
          <label class="text-xs text-[var(--muted)]">Balance (USDT)</label>
          <input id="balance" value="2000" class="w-full p-2 mt-1 rounded bg-[#071018] mono"/>
        </div>
        <div>
          <label class="text-xs text-[var(--muted)]">Risk %</label>
          <input id="riskPct" value="1" class="w-full p-2 mt-1 rounded bg-[#071018] mono"/>
        </div>
        <div>
          <label class="text-xs text-[var(--muted)]">Side</label>
          <select id="side" class="w-full p-2 mt-1 rounded bg-[#071018] mono"><option value="long">Long</option><option value="short">Short</option></select>
        </div>
      </div>

      <div class="flex gap-2 mt-4">
        <button id="evalBtn" class="flex-1 p-2 rounded-lg bg-[var(--accent)] text-black font-semibold">Evaluate plan</button>
        <button id="suggestBtn" class="flex-1 p-2 rounded-lg bg-[#3b82f6]">Suggest Mila levels</button>
      </div>

      <div id="planOutput" class="mt-4 text-sm mono">No plan analyzed yet.</div>
    </div>

  </section>
</main>

<!-- PWA manifest & SW will be created at runtime from this single file (no extra files required) -->

<script>
/* ================= CONFIG ================== */
/* You asked everything in single file — CMC key included (visible in source). */
const CMC_KEY = "7c349fb2-99f1-4e60-8a50-0b0323354923"; // your key (visible)
const BINANCE = "https://api.binance.com";
const COINGECKO = "https://api.coingecko.com/api/v3";

/* ====== UTILITIES ====== */
const $ = id=>document.getElementById(id);
const fmt = (n,d=4)=>Number.isFinite(n)? Number(n).toFixed(d): "—";
const msg = (s)=>{ $("statusPill").textContent = s; };

/* ====== Autocomplete (CoinGecko search) ====== */
let selectedCoin = null; // {id,symbol,name,thumb}
let chartInst = null;

async function searchCoins(term){
  if(!term || term.trim().length<1){ $("suggestions").innerHTML=""; return; }
  try{
    const res = await fetch(`${COINGECKO}/search?query=${encodeURIComponent(term)}`);
    const j = await res.json();
    const coins = j.coins.slice(0,8);
    const html = coins.map(c=>`
      <div class="flex items-center gap-3 p-2 hover:bg-[#061018] cursor-pointer" onclick='selectCoin(${JSON.stringify(JSON.stringify(c))})'>
        <img src="${c.thumb}" class="w-6 h-6 rounded-full"/>
        <div>
          <div class="mono">${c.name} <span class="text-[var(--muted)]">(${c.symbol.toUpperCase()})</span></div>
          <div class="text-[var(--muted)] text-xs">${c.market_cap_rank? "rank "+c.market_cap_rank : ""}</div>
        </div>
      </div>
    `).join("");
    $("suggestions").innerHTML = html;
  }catch(e){
    $("suggestions").innerHTML = `<div class="text-xs text-[var(--muted)] p-2">Search failed</div>`;
  }
}

/* Called on click — we get stringified JSON because of inline onclick */
function selectCoin(str){
  const coin = JSON.parse(str);
  selectedCoin = { id: coin.id, symbol: coin.symbol.toUpperCase(), name: coin.name, thumb: coin.thumb };
  $("search").value = selectedCoin.symbol;
  $("pairTitle").textContent = `${selectedCoin.name} (${selectedCoin.symbol})`;
  $("pairSub").textContent = `resolved via CoinGecko (trying Binance pair)`;
  $("suggestions").innerHTML = "";
  msg("coin selected");
}

/* ====== Resolve pair to Binance symbol if possible ====== */
async function resolveBinancePair(symbol, quote="USDT"){
  // Try common forms: SYMBOL+QUOTE, SYMBOL/QUOTE, COINGECKO -> binance symbol map
  const pair = (symbol+quote).toUpperCase();
  try{
    // quick ping: price endpoint to check existence
    const r = await fetch(`${BINANCE}/api/v3/ticker/price?symbol=${pair}`);
    if(r.ok){ return pair; }
  }catch(e){}
  // sometimes quote is different (BUSD etc.) - try fallback quotes
  const altQuotes = ["USDT","BUSD","USDC","BTC","ETH"];
  for(const q of altQuotes){
    try{
      const p = (symbol + q).toUpperCase();
      const r = await fetch(`${BINANCE}/api/v3/ticker/price?symbol=${p}`);
      if(r.ok) return p;
    }catch(e){}
  }
  return null;
}

/* ====== Klines fetch with multi-API fallback ====== */
async function fetchKlinesBest(symbolPair, interval, limit=500){
  // Try Binance first (full OHLCV)
  try{
    const r = await fetch(`${BINANCE}/api/v3/klines?symbol=${symbolPair}&interval=${interval}&limit=${limit}`);
    if(r.ok){
      const raw = await r.json();
      return raw.map(d=>({ t:+d[0], o:+d[1], h:+d[2], l:+d[3], c:+d[4], v:+d[5] }));
    }
  }catch(e){}
  // If binance fails, try CoinGecko OHLC (only supports certain day ranges) - fallback to price series
  try{
    // CoinGecko doesn't provide minute candles. We'll fallback to daily series if interval is daily.
    if(interval === "1d"){
      const cg = await fetch(`${COINGECKO}/coins/${selectedCoin.id}/ohlc?vs_currency=usd&days=14`).then(r=>r.json());
      // cg: [ [timestamp, open, high, low, close], ... ] ascending
      return cg.reverse().map(d=>({ t:d[0], o:d[1], h:d[2], l:d[3], c:d[4], v:0 }));
    }
  }catch(e){}
  // Final: try CMC historical OHLC (requires key)
  try{
    const sym = selectedCoin? selectedCoin.symbol : symbolPair.replace(/USDT|BUSD|USDC|BTC|ETH/gi,"");
    const url = `https://pro-api.coinmarketcap.com/v1/cryptocurrency/ohlcv/historical?symbol=${encodeURIComponent(sym)}&convert=USD&count=30`;
    const r = await fetch(url, { headers: {'X-CMC_PRO_API_KEY': CMC_KEY} });
    if(r.ok){
      const j = await r.json();
      // parse quotes -> descending
      const q = j.data.quotes.map(qi=>({ t: new Date(qi.time_open).getTime(), o: qi.quote.USD.open, h: qi.quote.USD.high, l: qi.quote.USD.low, c: qi.quote.USD.close, v: qi.quote.USD.volume }));
      return q.reverse();
    }
  }catch(e){}
  throw new Error("No OHLCV source available for this symbol.");
}

/* ====== Orderbook (Binance only) ====== */
async function fetchOrderbook(pair){
  try{
    const r = await fetch(`${BINANCE}/api/v3/depth?symbol=${pair}&limit=100`);
    if(!r.ok) throw new Error("OB fail");
    const j = await r.json();
    const bids = j.bids.map(b=>({p:+b[0], q:+b[1]}));
    const asks = j.asks.map(a=>({p:+a[0], q:+a[1]}));
    const bidQ = bids.reduce((s,b)=>s+b.q,0);
    const askQ = asks.reduce((s,a)=>s+a.q,0);
    const skew = (bidQ - askQ) / (bidQ + askQ);
    return { bids, asks, bidQ, askQ, skew };
  }catch(e){ return null; }
}

/* ====== Technical calculations ====== */
function emaArray(arr, period){
  if(arr.length < period) return Array(arr.length).fill(null);
  const k = 2/(period+1);
  let res = [];
  let prev = arr.slice(0,period).reduce((a,b)=>a+b,0)/period;
  res[period-1]=prev;
  for(let i=period;i<arr.length;i++){
    prev = arr[i]*k + prev*(1-k);
    res[i]=prev;
  }
  return res;
}

function computeADRFromDaily(dailyCandles){
  const ranges = dailyCandles.map(c=>Math.abs(c.h - c.l));
  const adr = ranges.reduce((a,b)=>a+b,0)/ranges.length;
  return adr;
}

function generatePsych(price){
  // step sizing by magnitude
  const magnitude = Math.pow(10, Math.floor(Math.log10(price)));
  let step;
  if(price>=1000) step = magnitude; // 1000s
  else if(price>=100) step = magnitude/10; // 10s
  else if(price>=10) step = magnitude/10; // 1s
  else if(price>=1) step = 0.1;
  else if(price>=0.1) step = 0.01;
  else step = 0.001;
  const center = Math.round(price/step)*step;
  const lvls = [];
  for(let i=-4;i<=4;i++) lvls.push(Number((center + i*step).toFixed(8)));
  return lvls;
}

function detectVectors(candles){
  // PVSRA-ish vector detection: body large vs range plus vol spike vs 20-period vol avg
  const vols = candles.map(c=>c.v || 0);
  const volSMA20 = [];
  for(let i=0;i<candles.length;i++){
    if(i<19) volSMA20.push(null);
    else volSMA20.push(vols.slice(i-19,i+1).reduce((s,x)=>s+x,0)/20);
  }
  const vectors = [];
  for(let i=0;i<candles.length;i++){
    const c = candles[i];
    const body = Math.abs(c.c - c.o);
    const range = c.h - c.l || 1;
    const bodyRatio = body / range;
    const volSpike = volSMA20[i] ? c.v > 1.6 * volSMA20[i] : false;
    if(bodyRatio >= 0.6 && volSpike) vectors.push({i,dir: c.c>c.o? 'green':'red', t:c.t, o:c.o, c:c.c, h:c.h, l:c.l});
  }
  return vectors;
}

/* ====== Session rhythm ====== */
function sessionByTimestamp(ts){
  // ts in ms (UTC)
  const d = new Date(ts);
  const hour = d.getUTCHours();
  // Asian: 00:00-06:59, London: 07:00-15:59, NY: 16:00-23:59 (rough)
  if(hour >= 0 && hour < 7) return 'Asian';
  if(hour >= 7 && hour < 16) return 'London';
  return 'New York';
}

/* ====== Mila core suggestions ====== */
function milaRecommendations(state, side='long'){
  // state: {price, adr, adrLo, adrHi, psych, emas, vectors, ob}
  const { price, adr, psych, emas, vectors, ob } = state;
  // bias
  let bias = 'neutral';
  if(price > (emas.e50?.slice(-1)[0] || price)) bias = 'bullish';
  if(price < (emas.e50?.slice(-1)[0] || price)) bias = 'bearish';
  // vector context
  const lastVec = vectors.slice(-4);
  const greens = lastVec.filter(v=>v.dir==='green').length;
  const reds = lastVec.filter(v=>v.dir==='red').length;
  // suggested risk
  const volPct = (state.adr / state.price);
  let suggestedRisk = 1.0;
  if(volPct > 0.06) suggestedRisk = 0.5;
  if(volPct < 0.02) suggestedRisk = 1.5;
  if(greens > reds && bias==='bullish') suggestedRisk = 0.5; // caution on green dominance high
  // suggested sl/tps
  let sSL, sTP1, sTP2, sTPF;
  if(side === 'long'){
    sSL = Math.max(state.adrLo * 0.995, price - state.adr*0.45);
    sTP1 = price + state.adr*0.5;
    sTP2 = Math.min(price + state.adr*0.9, state.adrHi*0.998);
    sTPF = Math.min(price + state.adr*1.3, state.adrHi*1.02);
  } else {
    sSL = Math.min(state.adrHi * 1.005, price + state.adr*0.45);
    sTP1 = price - state.adr*0.5;
    sTP2 = Math.max(price - state.adr*0.9, state.adrLo*1.002);
    sTPF = Math.max(price - state.adr*1.3, state.adrLo*0.98);
  }

  // psych intersection checks
  const nearestPsych = psych.reduce((acc,p)=> Math.abs(p - price) < Math.abs(acc - price) ? p : acc, psych[0]);

  return {
    bias, suggestedRisk, recommended: { sSL, sTP1, sTP2, sTPF }, nearestPsych
  };
}

/* ====== Chart helper ====== */
function renderChart(candles, emas){
  const ctx = document.getElementById('chart').getContext('2d');
  const dataset = candles.map(c=>({x:new Date(c.t), o:c.o, h:c.h, l:c.l, c:c.c}));
  const ema50Data = emas.e50.map((v,i)=>({x:new Date(candles[i].t), y:v}));
  const ema200Data = emas.e200.map((v,i)=>({x:new Date(candles[i].t), y:v}));
  if(chartInst) chartInst.destroy();
  chartInst = new Chart(ctx, {
    type: 'candlestick',
    data: { datasets: [
      { label:'Price', data: dataset },
      { label:'EMA50', type:'line', data: ema50Data, borderColor:'#00ff95', borderWidth:1.4, pointRadius:0 },
      { label:'EMA200', type:'line', data: ema200Data, borderColor:'#7aa2f7', borderWidth:1.2, pointRadius:0 }
    ]},
    options: {
      parsing: false, maintainAspectRatio:false,
      plugins:{ legend:{ labels:{ color:'#e6edf3' }}},
      scales:{ x:{ ticks:{ color:'#9aa4b2' }}, y:{ ticks:{ color:'#9aa4b2' }}}
    }
  });
}

/* ====== Plan evaluation & sizing ====== */
function evaluatePlan(form, state){
  const entry = +form.entry, stop = +form.stop, tp1 = +form.tp1, tp2 = +form.tp2, tpF = +form.tpF;
  const balance = +form.balance, riskPct = +form.riskPct, side = form.side;
  const riskAmt = balance*(riskPct/100);
  const stopDist = Math.abs(entry - stop);
  const qty = stopDist>0 ? (riskAmt/stopDist) : 0;
  const rr = (t)=> Math.abs((t - entry) / (entry - stop));
  const rec = milaRecommendations(state, side);

  // evaluation
  const issues = [];
  if(side === 'long' && entry > state.adrHi) issues.push("Entry above ADR high — high trap risk.");
  if(side === 'short' && entry < state.adrLo) issues.push("Entry below ADR low — high trap risk.");
  if(Math.abs(stop - rec.recommended.sSL) / Math.abs(rec.recommended.sSL) > 0.35) issues.push("Your SL is far from Mila's suggested SL.");
  if(Math.abs(tpF - rec.recommended.sTPF) / Math.abs(rec.recommended.sTPF) > 0.6) issues.push("Final TP is outside reasonable range (greedy).");

  return {
    sizing:{ riskAmt, qty },
    rrs: { r1: rr(tp1), r2: rr(tp2), rF: rr(tpF) },
    issues, rec
  };
}

/* ====== UI wiring ====== */

$("search").addEventListener("input", (e)=> searchCoins(e.target.value));

async function onFetchClick(){
  if(!selectedCoin){ alert("Type and select a coin from suggestions first."); return; }
  const quote = $("quote").value || "USDT";
  const tf = $("tf").value || "1h";
  msg("resolving pair...");
  // try resolve to Binance pair
  const binSym = await resolveBinancePair(selectedCoin.symbol.replace(/\s+/g,''), quote) || await resolveBinancePair(selectedCoin.symbol, quote);
  let usedSource = "binance";
  let pair = binSym;
  try{
    if(!pair) throw new Error("No Binance pair, will fallback to CMC/Coingecko.");
    msg("fetching klines from Binance...");
    const kl = await fetchKlinesBest(pair, tf, 400);
    // prepare state
    // use last 200 candles for analysis
    const candles = kl.slice(-200);
    const closes = candles.map(c=>c.c);
    const daily = await fetchKlinesBest(pair, "1d", 30).catch(()=>null); // try daily for ADR
    const adr = daily? computeADRFromDaily(daily) : (Math.max(...closes) - Math.min(...closes));
    const price = candles.at(-1).c;
    const psych = generatePsych(price);
    const e5 = emaArray(closes,5), e13 = emaArray(closes,13), e50 = emaArray(closes,50), e200 = emaArray(closes,200);
    const e800 = closes.length>=800? emaArray(closes,800) : null;
    const vectors = detectVectors(candles);
    const ob = await fetchOrderbook(pair).catch(()=>null);

    const state = {
      pair, source:usedSource, candles, price, adr, adrHi: price + adr, adrLo: price - adr,
      psych, emas: { e5,e13,e50,e200, e800 }, vectors, ob
    };

    // render UI blocks
    $("pairTitle").textContent = pair;
    $("pairSub").textContent = `${selectedCoin.name} • ${tf} • source: Binance`;
    $("priceLive").textContent = fmt(price, 6);
    $("sessionTag").textContent = sessionByTimestamp(candles.at(-1).t);

    updateBlocks(state);
    renderChart(candles, state.emas);

    // mila verdict
    const mil = milaRecommendations(state, "long");
    $("milaVerdict").innerHTML = `
      <div><b>Bias:</b> ${mil.bias} • <b>Suggested risk:</b> ${fmt(mil.suggestedRisk,1)}%</div>
      <div class="mt-2 text-[var(--muted)]">${mil.nearestPsych? "Nearest psych: "+fmt(mil.nearestPsych,6):""}</div>
      <div class="mt-2"><b>Recommended SL:</b> ${fmt(mil.recommended.sSL)} • <b>TP1:</b> ${fmt(mil.recommended.sTP1)} • <b>TP2:</b> ${fmt(mil.recommended.sTP2)} • <b>Final:</b> ${fmt(mil.recommended.sTPF)}</div>
    `;

    msg("analysis ready");

    // store last state
    window.__MILA_STATE = state;

  }catch(err){
    // Try CMC/Gecko fallback: pull price and produce sanity zone
    msg("fallback mode");
    try{
      // try CoinGecko price
      const id = selectedCoin.id;
      const cg = await fetch(`${COINGECKO}/simple/price?ids=${id}&vs_currencies=usd`).then(r=>r.json());
      const price = cg[id].usd;
      // crude ADR estimate (pct)
      const adr = price * 0.05;
      const psych = generatePsych(price);
      const state = {
        pair: selectedCoin.symbol + " (not on Binance)", source: "coingecko", candles:[], price, adr, adrHi:price+adr, adrLo:price-adr, psych,
        emas: { e5:[], e13:[], e50:[], e200:[] }, vectors:[], ob:null
      };
      $("pairTitle").textContent = selectedCoin.symbol + " (CG)";
      $("pairSub").textContent = selectedCoin.name + " • fallback data";
      $("priceLive").textContent = fmt(price,6);
      $("sessionTag").textContent = "N/A";
      updateBlocks(state);
      $("milaVerdict").innerHTML = `<div>Fallback sanity zone produced from coingecko price. For deeper TA, choose a Binance-listed coin.</div>`;
      window.__MILA_STATE = state;
      msg("fallback ready");
    }catch(e){
      msg("failed");
      alert("Unable to fetch data from Binance/CoinGecko/CMC for this coin.");
    }
  }
}

$("fetchBtn").addEventListener("click", onFetchClick);

/* update ADR / EMA / OB blocks */
function updateBlocks(state){
  // adr block
  $("adrBlock").innerHTML = `
    ADR(14): <b class="mono">${fmt(state.adr,6)}</b><br/>
    ADR Low: <span class="mono">${fmt(state.adrLo,6)}</span><br/>
    ADR High: <span class="mono">${fmt(state.adrHi,6)}</span><br/>
    Psych: ${state.psych.slice(0,7).map(p=>`<span class="pill mono">${fmt(p,6)}</span>`).join(' ')}
  `;
  // ema block
  const e = state.emas;
  $("emaBlock").innerHTML = `
    EMA5: <span class="mono">${e.e5?.at(-1)? fmt(e.e5.at(-1),6):'—'}</span><br/>
    EMA13: <span class="mono">${e.e13?.at(-1)? fmt(e.e13.at(-1),6):'—'}</span><br/>
    EMA50: <span class="mono">${e.e50?.at(-1)? fmt(e.e50.at(-1),6):'—'}</span><br/>
    EMA200: <span class="mono">${e.e200?.at(-1)? fmt(e.e200.at(-1),6):'—'}</span>
  `;
  // ob block
  if(state.ob){
    $("obBlock").innerHTML = `BidΣ: <span class="mono">${fmt(state.ob.bidQ,2)}</span> • AskΣ: <span class="mono">${fmt(state.ob.askQ,2)}</span> • Skew: <b>${(state.ob.skew>0) ? 'Bids' : 'Asks'}</b>`;
  } else {
    $("obBlock").innerHTML = `Orderbook not available.`;
  }
}

/* Evaluate plan */
$("evalBtn").addEventListener("click", ()=>{
  const st = window.__MILA_STATE;
  if(!st){ alert("Fetch a coin first"); return; }
  const form = {
    entry: +$("entry").value, stop: +$("stop").value, tp1: +$("tp1").value, tp2: +$("tp2").value, tpF: +$("tpF").value,
    balance:+$("balance").value, riskPct:+$("riskPct").value, side:$("side").value
  };
  if(!isFinite(form.entry) || !isFinite(form.stop)){ alert("Entry and Stop required"); return; }
  const res = evaluatePlan(form, st);
  let issuesHtml = res.issues.length? `<div class="text-sm text-[var(--danger)]">${res.issues.map(i=>`• ${i}`).join("<br>")}</div>` : `<div class="text-sm text-[var(--muted)]">No immediate structural issues.</div>`;
  $("planOutput").innerHTML = `
    <div>Risk $: <b class="mono">${fmt(res.sizing.riskAmt,2)}</b> • Qty: <b class="mono">${fmt(res.sizing.qty,6)}</b></div>
    <div class="mt-2">R:R → TP1: <b>${fmt(res.rrs.r1,2)}</b> • TP2: <b>${fmt(res.rrs.r2,2)}</b> • Final: <b>${fmt(res.rrs.rF,2)}</b></div>
    <div class="mt-3">${issuesHtml}</div>
    <div class="mt-3 text-xs text-[var(--muted)]">Mila suggested risk: <b>${fmt(res.rec.suggestedRisk,2)}%</b> • Nearest psych: <b>${fmt(res.rec.nearestPsych)}</b></div>
  `;
  if(res.issues.length) $("planOutput").classList.add("flash"); else $("planOutput").classList.remove("flash");
});

/* Suggest Mila levels auto-fill */
$("suggestBtn").addEventListener("click", ()=>{
  const st = window.__MILA_STATE;
  if(!st){ alert("Fetch a coin first"); return; }
  const rec = milaRecommendations(st, $("side").value);
  $("stop").value = fmt(rec.recommended.sSL,6);
  $("tp1").value = fmt(rec.recommended.sTP1,6);
  $("tp2").value = fmt(rec.recommended.sTP2,6);
  $("tpF").value = fmt(rec.recommended.sTPF,6);
  msg("Mila suggested levels filled");
});

/* reset */
$("resetBtn").addEventListener("click", ()=> location.reload());

/* small UI glue: suggestions click wiring helper (we used inline JSON) */
/* Not needed: selectCoin handled inline JSON string parse. */

/* ===== PWA: inline manifest & service worker registration via blob ===== */
(function registerPWA(){
  // manifest blob
  const manifest = {
    name: "Mila Trade Assistant",
    short_name: "MilaTA",
    start_url: ".",
    display: "standalone",
    background_color: "#0b0f14",
    theme_color: "#00ff95",
    icons: [
      { src: "data:image/svg+xml," + encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='512' height='512'><rect width='100%' height='100%' fill='#071018'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-size='120' fill='#00ff95' font-family='Arial'>TS</text></svg>`), sizes:"512x512", type:"image/svg+xml"}
    ]
  };
  const mm = new Blob([JSON.stringify(manifest)], {type:'application/json'});
  const mmUrl = URL.createObjectURL(mm);
  const link = document.createElement('link'); link.rel='manifest'; link.href = mmUrl;
  document.head.appendChild(link);

  // service worker blob
  const swCode = `
    const CACHE = 'mila-cache-v1';
    self.addEventListener('install', e => {
      e.waitUntil(caches.open(CACHE).then(c=>c.addAll(['/','/index.html'])));
      self.skipWaiting();
    });
    self.addEventListener('activate', e => { self.clients.claim(); });
    self.addEventListener('fetch', e => {
      e.respondWith(caches.match(e.request).then(r => r || fetch(e.request)));
    });
  `;
  const swBlob = new Blob([swCode], {type:'text/javascript'});
  const swUrl = URL.createObjectURL(swBlob);
  if('serviceWorker' in navigator){
    navigator.serviceWorker.register(swUrl).then(()=> console.log('SW registered inline')).catch(()=>{/*ignore*/});
  }
})();

/* Initial UI state */
msg("ready");

/* ===== End of file ===== */

</script>
</body>
</html>
